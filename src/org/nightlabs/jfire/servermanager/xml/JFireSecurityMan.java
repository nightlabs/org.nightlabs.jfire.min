/* *****************************************************************************
 * JFire - it's hot - Free ERP System - http://jfire.org                       *
 * Copyright (C) 2004-2005 NightLabs - http://NightLabs.org                    *
 *                                                                             *
 * This library is free software; you can redistribute it and/or               *
 * modify it under the terms of the GNU Lesser General Public                  *
 * License as published by the Free Software Foundation; either                *
 * version 2.1 of the License, or (at your option) any later version.          *
 *                                                                             *
 * This library is distributed in the hope that it will be useful,             *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of              *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *
 * Lesser General Public License for more details.                             *
 *                                                                             *
 * You should have received a copy of the GNU Lesser General Public            *
 * License along with this library; if not, write to the                       *
 *     Free Software Foundation, Inc.,                                         *
 *     51 Franklin St, Fifth Floor,                                            *
 *     Boston, MA  02110-1301  USA                                             *
 *                                                                             *
 * Or get it online :                                                          *
 *     http://opensource.org/licenses/lgpl-license.php                         *
 *                                                                             *
 *                                                                             *
 ******************************************************************************/

package org.nightlabs.jfire.servermanager.xml;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.nightlabs.xml.DOMParser;
import org.nightlabs.xml.NLDOMUtil;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

/**
 * @author marco
 */
public class JFireSecurityMan implements Serializable
{
	/**
	 * The serial version of this class.
	 */
	private static final long serialVersionUID = 1L;
	
	/**
	 * LOG4J logger used by this class
	 */
	private static final Logger logger = Logger.getLogger(JFireSecurityMan.class);

	protected EJBJarMan ejbJarMan = null;
	
	/**
	 * key: String roleGroupID<br/>
	 * value: RoleGroup roleGroup<br/>
	 */
	private Map<String, RoleGroupDef> roleGroups = new HashMap<String, RoleGroupDef>();

	/**
	 * key: String roleID<br/>
	 * value: RoleDef role<br/>
	 * <br/>
	 * This Map stores all roles that have
	 * been declared in jfire-security.xml. This is necessary to diff the roles that
	 * need to be put into a fallback role-group or if there is no ejbJarMan (in global usage).
	 */
	private Map<String, RoleDef> roles = new HashMap<String, RoleDef>();

	/**
	 * key: String authorityTypeID<br/>
	 * value: AuthorityTypeDef authorityTypeDef<br/>
	 */
	private Map<String, AuthorityTypeDef> authorityTypes = new HashMap<String, AuthorityTypeDef>();

//	protected String defaultGroupID = null;
	
	private SAXParseException parseException = null;

	public JFireSecurityMan()
	{
	}
	
	public JFireSecurityMan(EJBJarMan _ejbJarMan)
	throws SAXException, IOException, XMLReadException
	{
		this.ejbJarMan = _ejbJarMan;
		for (RoleDef roleDef : ejbJarMan.getRoles()) {
			this.roles.put(roleDef.getRoleID(), roleDef);
		}
	}

	/**
	 * If a role is not mentioned in any role-group, a fallback role-group with the same id is generated by this method (and a warning logged).
	 */
	public void createFallbackRoleGroups()
	{
		Set<String> roleIDsWithRoleGroup = new HashSet<String>();

		for (RoleGroupDef roleGroupDef : roleGroups.values())
			roleIDsWithRoleGroup.addAll(roleGroupDef.getRoleIDs());

		for (String roleID : roles.keySet()) {
			if (roleIDsWithRoleGroup.contains(roleID))
				continue;

			RoleGroupDef roleGroupDef = roleGroups.get(roleID);
			if (roleGroupDef != null)
				logger.warn("createFallbackRoleGroups: the role \"" + roleID + "\" is in no role-group. Using other role-group as fallback-role-group, since it already exists with roleGroupID = roleID.");
			else {
				logger.warn("createFallbackRoleGroups: the role \"" + roleID + "\" is in no role-group. Creating fallback-role-group with same id.");
				roleGroupDef = new RoleGroupDef(roleID);
				roleGroups.put(roleID, roleGroupDef);
			}

			roleGroupDef.addRole(roleID);
		}

//		if (defaultGroupID != null)
//			return;
//		
//		if (ejbJarMan.getRoles().isEmpty())
//			return;
//
////		SimpleDateFormat df = new SimpleDateFormat();
////		df.applyPattern("yyyyMMddHHmmss");
////		String id = df.format(new Date());
//		String id = ejbJarMan.getJFireModuleName() + ".fallback";
//
//		RoleGroupDef rgd = new RoleGroupDef(this, id, true);
//		rgd.setName(null, "Autogenerated default rolegroup " + id);
//		rgd.setDescription(null, "This rolegroup has been autogenerated, because the module "+ejbJarMan.getJFireModuleName()+" does not define a default rolegroup in its jfire-security.xml.");
//		defaultGroupID = id;
//		addRoleGroup(rgd);
	}

	private RoleDef parseRole(Node node)
	{
		String roleID = NLDOMUtil.getNonEmptyAttributeValue(node, "id").trim();

		if (roleID.startsWith("_")) // internal roles like _ServerAdmin_
			return null;

		RoleDef role = roles.get(roleID);
		if (role == null) {
			if (logger.isDebugEnabled())
				logger.debug("parseRole: Adding role: \""+roleID+"\"");

			role = new RoleDef(roleID);
		}
		roles.put(roleID, role);

		NodeList nl = node.getChildNodes();
		for (int i = 0; i < nl.getLength(); ++i) {
			Node n = nl.item(i);

			if ("name".equals(n.getLocalName())) {
				role.setName(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(node)
				);
			}

			if ("description".equals(n.getLocalName())) {
				role.setDescription(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(node)
				);
			}
		}

		return role;
	}

	private RoleGroupDef parseRoleGroup(Node node)
	{
		String roleGroupID = NLDOMUtil.getNonEmptyAttributeValue(node, "id").trim();

		RoleGroupDef roleGroup = roleGroups.get(roleGroupID);
		if (roleGroup == null) {
			if (logger.isDebugEnabled())
				logger.debug("parseRoleGroup: Adding role-group: \""+roleGroupID+"\"");
			
			roleGroup = new RoleGroupDef(roleGroupID);
			roleGroups.put(roleGroupID, roleGroup);
		}

		NodeList nl = node.getChildNodes();
		for (int i = 0; i < nl.getLength(); ++i) {
			Node n = nl.item(i);

			if ("name".equals(n.getLocalName())) {
				roleGroup.setName(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(node)
				);
			}

			if ("description".equals(n.getLocalName())) {
				roleGroup.setDescription(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(node)
				);
			}

			if ("role".equals(n.getLocalName())) {
				RoleDef roleDef = parseRole(n);
				if (roleDef != null)
					roleGroup.addRole(roleDef.getRoleID());
			}

			if ("include-role-group".equals(n.getLocalName())) {
				roleGroup.addIncludedRoleGroup(
						NLDOMUtil.getNonEmptyAttributeValue(n, "id")
				);
			}
		}

		return roleGroup;
	}

	private AuthorityTypeDef parseAuthorityType(Node node)
	{
		String authorityTypeID = NLDOMUtil.getNonEmptyAttributeValue(node, "id").trim();

		AuthorityTypeDef authorityTypeDef = authorityTypes.get(authorityTypeID);
		if (authorityTypeDef == null) {
			if (logger.isDebugEnabled())
				logger.debug("Adding authority-type: \""+authorityTypeID+"\"");

			authorityTypeDef = new AuthorityTypeDef(authorityTypeID);
			authorityTypes.put(authorityTypeID, authorityTypeDef);
		}

		NodeList nl = node.getChildNodes();
		for (int i = 0; i < nl.getLength(); ++i) {
			Node n = nl.item(i);

			if ("name".equals(n.getLocalName())) {
				authorityTypeDef.setName(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(node)
				);
			}

			if ("description".equals(n.getLocalName())) {
				authorityTypeDef.setDescription(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(node)
				);
			}

			if ("role-group".equals(n.getLocalName())) {
				RoleGroupDef roleGroupDef = parseRoleGroup(n);
				if (roleGroupDef != null)
				authorityTypeDef.addRoleGroup(roleGroupDef.getRoleGroupID());
			}
		}

		return authorityTypeDef;
	}

	public JFireSecurityMan(EJBJarMan _ejbJarMan, InputStream ejbJarIn)
	throws SAXException, IOException, XMLReadException
	{
		this(_ejbJarMan);
		InputSource inputSource = new InputSource(ejbJarIn);
		DOMParser parser = new DOMParser();
//		parser.setValidate(false);
//		// list of features: http://xml.apache.org/xerces2-j/features.html
//		parser.setFeature("http://xml.org/sax/features/validation", false);
		parser.setErrorHandler(new ErrorHandler(){
			public void error(SAXParseException exception) throws SAXException {
				logger.error("Parse (jfire-security.xml): ", exception);
				parseException = exception;
			}

			public void fatalError(SAXParseException exception) throws SAXException {
				logger.fatal("Parse (jfire-security.xml): ", exception);
				parseException = exception;
			}

			public void warning(SAXParseException exception) throws SAXException {
				logger.warn("Parse (jfire-security.xml): ", exception);
			}
		});
		parser.parse(inputSource);
		if (parseException != null)
			throw parseException;

		for (Node n1 : NLDOMUtil.findNodeList(parser.getDocument(), "jfire-security")) {
			NodeList nl2 = n1.getChildNodes();
			for (int i2 = 0; i2 < nl2.getLength(); ++i2) {
				Node n2 = nl2.item(i2);
				if ("role".equals(n2.getLocalName()))
					parseRole(n2);
				else if ("role-group".equals(n2.getLocalName()))
					parseRoleGroup(n2);
				else if ("authority-type".equals(n2.getLocalName()))
					parseAuthorityType(n2);
			}
		}

//		NodeList nl = parser.getDocument().getElementsByTagName("ejb-rolegroup");
//		if (nl.getLength() > 0) {
//			Element elEjbRoleGroup = (Element)nl.item(0);
//			nl = elEjbRoleGroup.getElementsByTagName("rolegroups");
//			if (nl.getLength() > 0) {
//				Element elRoleGroups = (Element)nl.item(0);
//				this.defaultGroupID = elRoleGroups.getAttribute("defaultgroup");
//
//				NodeList roleGroups = elRoleGroups.getElementsByTagName("rolegroup");
//				for (int i = 0; i < roleGroups.getLength(); ++i) {
//					Element elRoleGroup = (Element)roleGroups.item(i);
//					String roleGroupID = elRoleGroup.getAttribute("id");
//					if (roleGroupID == null)
//						throw new XMLReadException("Attribute \"rolegroup.id\" missing!");
//
//					RoleGroupDef roleGroupDef = new RoleGroupDef(
//							this, roleGroupID,
//							defaultGroupID == null ? false : defaultGroupID.equals(roleGroupID));
//					
//					nl = elRoleGroup.getChildNodes();
//					for (int k = 0; k < nl.getLength(); ++k) {
//						Node n = nl.item(k);
//						if (!"name".equals(n.getLocalName()))
//							continue;
//						Node ntxt = n.getFirstChild();
//						if (ntxt instanceof Text) {
//							String languageID = ((Element)n).getAttribute("language");
//							String name = ((Text)ntxt).getData();
//							roleGroupDef.setName(languageID, name);
//						}
//					}
//
//					nl = elRoleGroup.getChildNodes();
//					for (int k = 0; k < nl.getLength(); ++k) {
//						Node n = nl.item(k);
//						if (!"description".equals(n.getLocalName()))
//							continue;
//						Node ntxt = n.getFirstChild();
//						if (ntxt instanceof Text) {
//							String languageID = ((Element)n).getAttribute("language");
//							String description = ((Text)ntxt).getData();
//							roleGroupDef.setDescription(languageID, description);
//						}
//					}
//
//					nl = elRoleGroup.getElementsByTagName("includerolegroup");
//					for (int j = 0; j < nl.getLength(); ++j) {
//						Element el = (Element)nl.item(j);
//						String includeRoleGroupID = el.getAttribute("id");
//						roleGroupDef.addIncludedRoleGroup(includeRoleGroupID);
//					}
//
//					nl = elRoleGroup.getElementsByTagName("roles");
//					if (nl.getLength() > 0) {
//						Element elRoles = (Element) nl.item(0);
//						NodeList nlRoles = elRoles.getElementsByTagName("role");
//						for (int j = 0; j < nlRoles.getLength(); ++j) {
//							Element elRole = (Element)nlRoles.item(j);
//	
//							String roleID = elRole.getAttribute("id");
//							if (roleID == null)
//								throw new XMLReadException("Attribute \"role.id\" missing!");
//							
//							RoleDef role = ejbJarMan.getRole(roleID);
//							if (role == null) {
//								if (logger.isDebugEnabled())
//									logger.debug("Role \""+roleID+"\" declared in jfire-security.xml is not defined in ejb-jar.xml - adding it now.");
//
//								role = new RoleDef(roleID);
//								ejbJarMan.addRole(role);
//							}
//
//							nl = elRole.getElementsByTagName("name");
//							for (int k = 0; k < nl.getLength(); ++k) {
//								Node n = nl.item(k);
//								Node ntxt = n.getFirstChild();
//								if (ntxt instanceof Text) {
//									String languageID = ((Element)n).getAttribute("language");
//									String name = ((Text)ntxt).getData();
//									role.setName(languageID, name);
//								}
//							}
//
//							nl = elRole.getElementsByTagName("description");
//							for (int k = 0; k < nl.getLength(); ++k) {
//								Node n = nl.item(k);
//								Node ntxt = n.getFirstChild();
//								if (ntxt instanceof Text) {
//									String languageID = ((Element)n).getAttribute("language");
//									String description = ((Text)ntxt).getData();
//									role.setDescription(languageID, description);
//								}
//							}
//
//							roles.put(roleID, role);
//							roleGroupDef.addRole(role);
//						} // for (int j = 0; j < roles.getLength(); ++j) { // role
//					} // if (nl.getLength() > 0) { // roles
//
//					addRoleGroup(roleGroupDef);
//				} // for (int i = 0; i < roleGroups.getLength(); ++i) { // rolegroup
//			} //	if (nl.getLength() > 0) { // rolegroups
//		} // if (nl.getLength() > 0) { // ejb-rolegroup
	}

	public RoleGroupDef getRoleGroup(String roleGroupID)
	{
		return roleGroups.get(roleGroupID);
	}

	public Map<String, RoleGroupDef> getRoleGroups()
	{
		return Collections.unmodifiableMap(roleGroups);
	}

//	public void addRoleGroup(RoleGroupDef roleGroup)
//	{
//		if (this != roleGroup.getOwner())
//			throw new IllegalArgumentException("owner of roleGroup is not this JFireSecurityMan!");
//		roleGroups.put(roleGroup.getRoleGroupID(), roleGroup);
//	}

	public Map<String, RoleDef> getRoles() {
		return Collections.unmodifiableMap(roles);
	}

	public void mergeSecurityMan(JFireSecurityMan other)
	{
		for (RoleDef otherRoleDef : other.roles.values()) {
			String roleID = otherRoleDef.getRoleID();
			RoleDef thisRoleDef = roles.get(roleID);
			if (thisRoleDef == null) {
				thisRoleDef = new RoleDef(roleID);
				roles.put(roleID, thisRoleDef);
			}
			thisRoleDef.mergeFrom(this, otherRoleDef);
		}

		for (RoleGroupDef otherRoleGroupDef : other.roleGroups.values()) {
			String roleGroupID = otherRoleGroupDef.getRoleGroupID();
			RoleGroupDef thisRoleGroupDef = roleGroups.get(roleGroupID);
			if (thisRoleGroupDef == null) {
				thisRoleGroupDef = new RoleGroupDef(roleGroupID);
				roleGroups.put(roleGroupID, thisRoleGroupDef);
			}
			thisRoleGroupDef.mergeFrom(this, otherRoleGroupDef);
		}

		for (AuthorityTypeDef otherAuthorityTypeDef : other.authorityTypes.values()) {
			String authorityTypeID = otherAuthorityTypeDef.getAuthorityTypeID();
			AuthorityTypeDef thisAuthorityTypeDef = authorityTypes.get(authorityTypeID);
			if (thisAuthorityTypeDef == null) {
				thisAuthorityTypeDef = new AuthorityTypeDef(authorityTypeID);
				authorityTypes.put(authorityTypeID, thisAuthorityTypeDef);
			}
			thisAuthorityTypeDef.mergeFrom(this, otherAuthorityTypeDef);
		}
	}

	public Map<String, AuthorityTypeDef> getAuthorityTypes() {
		return Collections.unmodifiableMap(authorityTypes);
	}

	public RoleDef getRole(String roleID)
	{
		return roles.get(roleID);
	}

	public void resolve()
	{
		Set<String> roleIDsInRoleGroups = new HashSet<String>();

		for (RoleGroupDef roleGroupDef : roleGroups.values()) {
			roleIDsInRoleGroups.addAll(roleGroupDef.getRoleIDs());
			roleGroupDef.resolve(this);
		}

		for (AuthorityTypeDef authorityTypeDef : authorityTypes.values())
			authorityTypeDef.resolve(this);

		// and create roleGroups for every role that has no role-group
		
	}

//	/**
//	 * This method diffs all the roles that have been declared in ejb-jar.xml, but not in
//	 * jfire-security.xml. They are put into the defaultGroup if one is existent.
//	 * 
//	 * @return A Collection with instances of type RoleDef.
//	 */
//	public Collection<RoleDef> getRolesInDefaultGroup()
//	{
//		Set<RoleDef> _roles = new HashSet<RoleDef>();
//
//		if (ejbJarMan != null) {
//			for (Iterator<RoleDef> it = ejbJarMan.getRoles().iterator(); it.hasNext(); ) {
//				RoleDef roleDef = it.next();
//				if (!roles.containsKey(roleDef.getRoleID()))
//					_roles.add(roleDef);
//			}
//		}
//
//		return _roles;
//	}

//	public void removeRole(String roleID)
//	{
//		if (roles.remove(roleID) != null) {
//			for (RoleGroupDef roleGroup : roleGroups.values())
//				roleGroup.removeRole(roleID);
//		}
//	}

}
