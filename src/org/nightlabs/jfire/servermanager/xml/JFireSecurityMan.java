/* *****************************************************************************
 * JFire - it's hot - Free ERP System - http://jfire.org                       *
 * Copyright (C) 2004-2005 NightLabs - http://NightLabs.org                    *
 *                                                                             *
 * This library is free software; you can redistribute it and/or               *
 * modify it under the terms of the GNU Lesser General Public                  *
 * License as published by the Free Software Foundation; either                *
 * version 2.1 of the License, or (at your option) any later version.          *
 *                                                                             *
 * This library is distributed in the hope that it will be useful,             *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of              *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           *
 * Lesser General Public License for more details.                             *
 *                                                                             *
 * You should have received a copy of the GNU Lesser General Public            *
 * License along with this library; if not, write to the                       *
 *     Free Software Foundation, Inc.,                                         *
 *     51 Franklin St, Fifth Floor,                                            *
 *     Boston, MA  02110-1301  USA                                             *
 *                                                                             *
 * Or get it online :                                                          *
 *     http://opensource.org/licenses/lgpl-license.php                         *
 *                                                                             *
 *                                                                             *
 ******************************************************************************/

package org.nightlabs.jfire.servermanager.xml;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.nightlabs.xml.DOMParser;
import org.nightlabs.xml.NLDOMUtil;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

/**
 * @author marco
 */
public class JFireSecurityMan implements Serializable
{
	/**
	 * The serial version of this class.
	 */
	private static final long serialVersionUID = 1L;
	
	/**
	 * LOG4J logger used by this class
	 */
	private static final Logger logger = Logger.getLogger(JFireSecurityMan.class);

	protected EJBJarMan ejbJarMan = null;
	
	/**
	 * key: String roleGroupID<br/>
	 * value: RoleGroup roleGroup<br/>
	 */
	private Map<String, RoleGroupDef> roleGroups = new HashMap<String, RoleGroupDef>();

	/**
	 * key: String roleID<br/>
	 * value: RoleDef role<br/>
	 * <br/>
	 * This Map stores all roles that have been declared in jfire-security.xml. Additionally,
	 * during creation, all roles are copied from the {@link EJBJarMan} (if there is one).
	 * The {@link RoleDef} instances are the same (they are not cloned) here and in {@link EJBJarMan}.
	 */
	private Map<String, RoleDef> roles = new HashMap<String, RoleDef>();

	/**
	 * key: String authorityTypeID<br/>
	 * value: AuthorityTypeDef authorityTypeDef<br/>
	 */
	private Map<String, AuthorityTypeDef> authorityTypes = new HashMap<String, AuthorityTypeDef>();

	private SAXParseException parseException = null;

	public JFireSecurityMan()
	{
	}
	
	public JFireSecurityMan(EJBJarMan _ejbJarMan)
	throws SAXException, IOException, XMLReadException
	{
		this.ejbJarMan = _ejbJarMan;
		if (ejbJarMan != null) {
			for (RoleDef roleDef : ejbJarMan.getRoles()) {
				this.roles.put(roleDef.getRoleID(), roleDef);
			}
		}
	}

	/**
	 * If a role is not mentioned in any role-group, a fallback role-group with the same id is generated by this method (and a warning logged).
	 */
	public void createFallbackRoleGroups()
	{
		Set<String> roleIDsWithRoleGroup = new HashSet<String>();

		for (RoleGroupDef roleGroupDef : roleGroups.values())
			roleIDsWithRoleGroup.addAll(roleGroupDef.getRoleIDs());

		for (String roleID : roles.keySet()) {
			if (roleIDsWithRoleGroup.contains(roleID))
				continue;

			RoleGroupDef roleGroupDef = roleGroups.get(roleID);
			if (roleGroupDef != null)
				logger.warn("createFallbackRoleGroups: the role \"" + roleID + "\" is in no role-group. Using other role-group as fallback-role-group, since it already exists with roleGroupID = roleID.");
			else {
				logger.warn("createFallbackRoleGroups: the role \"" + roleID + "\" is in no role-group. Creating fallback-role-group with same id.");
				roleGroupDef = new RoleGroupDef(roleID);
				roleGroups.put(roleID, roleGroupDef);
			}

			roleGroupDef.addRole(roleID);
		}
	}

	private RoleDef parseRole(Node node)
	{
		String roleID = NLDOMUtil.getNonEmptyAttributeValue(node, "id").trim();

		if (roleID.startsWith("_")) // internal roles like _ServerAdmin_
			return null;

		RoleDef role = roles.get(roleID);
		if (role == null) {
			if (logger.isDebugEnabled())
				logger.debug("parseRole: Adding role: \""+roleID+"\"");

			role = new RoleDef(roleID);
		}
		roles.put(roleID, role);

		NodeList nl = node.getChildNodes();
		for (int i = 0; i < nl.getLength(); ++i) {
			Node n = nl.item(i);

			if ("name".equals(n.getLocalName())) {
				role.setName(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(n, true)
				);
			}

			if ("description".equals(n.getLocalName())) {
				role.setDescription(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(n, true)
				);
			}
		}

		return role;
	}

	private RoleGroupDef parseRoleGroup(Node node)
	{
		String roleGroupID = NLDOMUtil.getNonEmptyAttributeValue(node, "id").trim();

		RoleGroupDef roleGroup = roleGroups.get(roleGroupID);
		if (roleGroup == null) {
			if (logger.isDebugEnabled())
				logger.debug("parseRoleGroup: Adding role-group: \""+roleGroupID+"\"");
			
			roleGroup = new RoleGroupDef(roleGroupID);
			roleGroups.put(roleGroupID, roleGroup);
		}

		NodeList nl = node.getChildNodes();
		for (int i = 0; i < nl.getLength(); ++i) {
			Node n = nl.item(i);

			if ("name".equals(n.getLocalName())) {
				roleGroup.setName(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(n, true)
				);
			}

			if ("description".equals(n.getLocalName())) {
				roleGroup.setDescription(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(n, true)
				);
			}

			if ("role".equals(n.getLocalName())) {
				RoleDef roleDef = parseRole(n);
				if (roleDef != null)
					roleGroup.addRole(roleDef.getRoleID());
			}

			if ("include-role-group".equals(n.getLocalName())) {
				roleGroup.addIncludedRoleGroup(
						NLDOMUtil.getNonEmptyAttributeValue(n, "id")
				);
			}
		}

		return roleGroup;
	}

	private AuthorityTypeDef parseAuthorityType(Node node)
	{
		String authorityTypeID = NLDOMUtil.getNonEmptyAttributeValue(node, "id").trim();

		AuthorityTypeDef authorityTypeDef = authorityTypes.get(authorityTypeID);
		if (authorityTypeDef == null) {
			if (logger.isDebugEnabled())
				logger.debug("Adding authority-type: \""+authorityTypeID+"\"");

			authorityTypeDef = new AuthorityTypeDef(authorityTypeID);
			authorityTypes.put(authorityTypeID, authorityTypeDef);
		}

		NodeList nl = node.getChildNodes();
		for (int i = 0; i < nl.getLength(); ++i) {
			Node n = nl.item(i);

			if ("name".equals(n.getLocalName())) {
				authorityTypeDef.setName(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(n, true)
				);
			}

			if ("description".equals(n.getLocalName())) {
				authorityTypeDef.setDescription(
						NLDOMUtil.getAttributeValue(n, "language"),
						NLDOMUtil.getTextContent(n, true)
				);
			}

			if ("role-group".equals(n.getLocalName())) {
				RoleGroupDef roleGroupDef = parseRoleGroup(n);
				if (roleGroupDef != null)
				authorityTypeDef.addRoleGroup(roleGroupDef.getRoleGroupID());
			}
		}

		return authorityTypeDef;
	}

	public JFireSecurityMan(EJBJarMan _ejbJarMan, InputStream ejbJarIn)
	throws SAXException, IOException, XMLReadException
	{
		this(_ejbJarMan);
		InputSource inputSource = new InputSource(ejbJarIn);
		DOMParser parser = new DOMParser();
//		parser.setValidate(false);
//		// list of features: http://xml.apache.org/xerces2-j/features.html
//		parser.setFeature("http://xml.org/sax/features/validation", false);
		parser.setErrorHandler(new ErrorHandler(){
			public void error(SAXParseException exception) throws SAXException {
				logger.error("Parse (jfire-security.xml): ", exception);
				parseException = exception;
			}

			public void fatalError(SAXParseException exception) throws SAXException {
				logger.fatal("Parse (jfire-security.xml): ", exception);
				parseException = exception;
			}

			public void warning(SAXParseException exception) throws SAXException {
				logger.warn("Parse (jfire-security.xml): ", exception);
			}
		});
		parser.parse(inputSource);
		if (parseException != null)
			throw parseException;

		for (Node n1 : NLDOMUtil.findNodeList(parser.getDocument(), "jfire-security")) {
			NodeList nl2 = n1.getChildNodes();
			for (int i2 = 0; i2 < nl2.getLength(); ++i2) {
				Node n2 = nl2.item(i2);
				if ("role".equals(n2.getLocalName()))
					parseRole(n2);
				else if ("role-group".equals(n2.getLocalName()))
					parseRoleGroup(n2);
				else if ("authority-type".equals(n2.getLocalName()))
					parseAuthorityType(n2);
			}
		}
	}

	public RoleGroupDef getRoleGroup(String roleGroupID)
	{
		return roleGroups.get(roleGroupID);
	}

	public Map<String, RoleGroupDef> getRoleGroups()
	{
		return Collections.unmodifiableMap(roleGroups);
	}

	public Map<String, RoleDef> getRoles() {
		return Collections.unmodifiableMap(roles);
	}

	public void mergeSecurityMan(JFireSecurityMan other)
	{
		for (RoleDef otherRoleDef : other.roles.values()) {
			String roleID = otherRoleDef.getRoleID();
			RoleDef thisRoleDef = roles.get(roleID);
			if (thisRoleDef == null) {
				thisRoleDef = new RoleDef(roleID);
				roles.put(roleID, thisRoleDef);
			}
			thisRoleDef.mergeFrom(this, otherRoleDef);
		}

		for (RoleGroupDef otherRoleGroupDef : other.roleGroups.values()) {
			String roleGroupID = otherRoleGroupDef.getRoleGroupID();
			RoleGroupDef thisRoleGroupDef = roleGroups.get(roleGroupID);
			if (thisRoleGroupDef == null) {
				thisRoleGroupDef = new RoleGroupDef(roleGroupID);
				roleGroups.put(roleGroupID, thisRoleGroupDef);
			}
			thisRoleGroupDef.mergeFrom(this, otherRoleGroupDef);
		}

		for (AuthorityTypeDef otherAuthorityTypeDef : other.authorityTypes.values()) {
			String authorityTypeID = otherAuthorityTypeDef.getAuthorityTypeID();
			AuthorityTypeDef thisAuthorityTypeDef = authorityTypes.get(authorityTypeID);
			if (thisAuthorityTypeDef == null) {
				thisAuthorityTypeDef = new AuthorityTypeDef(authorityTypeID);
				authorityTypes.put(authorityTypeID, thisAuthorityTypeDef);
			}
			thisAuthorityTypeDef.mergeFrom(this, otherAuthorityTypeDef);
		}
	}

	public Map<String, AuthorityTypeDef> getAuthorityTypes() {
		return Collections.unmodifiableMap(authorityTypes);
	}

	public RoleDef getRole(String roleID)
	{
		return roles.get(roleID);
	}

	public void resolve()
	{
		Set<String> roleIDsInRoleGroups = new HashSet<String>();

		for (RoleGroupDef roleGroupDef : roleGroups.values()) {
			roleIDsInRoleGroups.addAll(roleGroupDef.getRoleIDs());
			roleGroupDef.resolve(this);
		}

		for (AuthorityTypeDef authorityTypeDef : authorityTypes.values())
			authorityTypeDef.resolve(this);

		// and create roleGroups for every role that has no role-group
		
	}
}
